# HTTP/2

## 多路复用

一个 `TCP` 连接能传输多个资源，而不再是一个连接对应一个资源

### 历代版本面临的问题

`HTTP 1.0`

**队头阻塞** 一个请求对应一个 `TCP` 连接，而且前一个请求响应完，后一个才能发送

`HTTP 1.1`

`connection: keep-alive` 能避免响应完一个请求，就关掉 `TCP` 连接

**管道化** 客户端 `请求队列` ，把问题和责任扔给了服务器 `响应队列` 

但也只是 `假并行传输`，因为只是阻塞转移到了服务器

所以现在普遍的方案是，浏览器厂家自己作了优化，给一个页面(同一个域)多开几个 `TCP` 会话的能力，实现了 `真并行传输`。但这个多开数，各家浏览器都有自己的限制，最多那个都不超过 `6`

`HTTP/2`

真正的无请求数限制的同步加载

网页资源加载过程会变为：

* 先是请求第一个文档，耗费第一次连接
* 响应回来后，开始解析文档 `HTML`，得知需要哪些 `JS/CSS`
* 然后紧接着的第二次连接，就直接把这些 `JS/CSS` 全部都请求掉
* 假如响应回来的 `JS` 还需要下一批资源，就重复上述过程

总的连接数可能也就 2 ~ 3 个，非常的高效

### 协议底层

`二进制帧层`

    帧 最小基本单位

    流

    消息

## 头部压缩

服务器和客户端同时维护一份 `Header` 的 `key-value` 表

对于下一个的资源请求

* 假如某个头字段和值在表里有(即跟上一个资源的请求头相同)，则这次就不用携带
* 假如某个头字段在表里没有(即新出现的)，则携带上，且 `k-v` 表 `push` 这个 `k-v`
* 假如某个头字段的值不一样了，则携带上，且 `k-v` 表 `update` 这个 `v`

这个特性有利于 **动态请求**，就是那些数据才 `几字节`，结果每次都要附带头报文，占几百字节

## 服务端推送

`nginx` 暂不支持 `Server Push`，一些 `node` 的库可以

## 旧项目迁移到 HTTP/2 要注意的

* 曾经针对 `HTTP/1` 的 hack优化要改回来。比如：

    雪碧图

    inline js/css 注入

    域名打散

    (否则反过来影响性能)

* 项目必须是多请求为主的，像流服务器，提供大视频、大图片下载的，就不必升级
* 可以 `cdn` 用 `HTTP/2`，前端服务用 `HTTP 1.0` `HTTP 1.1` 混合